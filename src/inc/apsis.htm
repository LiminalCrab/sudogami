<main>
    <div class="wiki-content">

        <!-- OPTIONAL BANNER -->
         <!-- <center><img src='../gallery/wiki-auger.png' alt='Auger' height='500px'></a></center> --> 
         <h3>START apsis [2021/06/27 0729]</h3>
        <span><p>This project is going to be a behemoth of low level network programming with C, but one I'm very excited to begin. Apsis is a global metronome, the goal
         of Apsis is to keep artists conducting live performances over livestreams (network music performances) synchronized using a global pulse signal and a very
         precise time synchornization server I'm calling "Synapsys" or "Apsis Syncrhonized Systems" because I'm cool. Apsis itself will have a user interface built with SDL,
         where Synapsys will be your standard server CLI. It will require a Leader/Follower layout, where we have a leader metronome which will likely be tied to the individual with the lowest latencey
        and the Followers starting from the second lowest latency down. My reason for this is due to how the artists will have to hear one another. Speaking of hearing each other,
    for audio I/O I'll be using OpenAL. So, in general this project will be a combination of network programming, UI programming, and audio programming. All written in C. How exciting.</span></p> 
        <h3> CONTINUE apsis [2021/06/27 2050]</h3>
        <span><p> In order to keep the init function running, I've switched it to a boolean value, inside is a boolean value called is_running, and it's set to true upon initalization. The window
            will be established, pWindow (parent window), will be defined at a width of 640, and a height of 480 at a undefined position on the screen. (Will make this adjustable in the future, but for prototyping
            this will have to work for now). When experimenting with SDL, I used SDL_GetTicks to keep a window running momentarily, about five seconds just to get a glimpse of it, but this isn't sufficient for long term
            for the obvious reason. Also, there was an SDL_Delay command that doesn't work on Unix, it won't render anything because it pauses the thread entirely, so SDL_GetTicks became necessary.</p></span>
       
        <span><p> is_running will be set to true while the program is initalized, in order to exit, is_running will be set to false, once it's set to false we'll call the apsis_quit(); function and exit the program safely. 
            When I say "we", I mean, me and the program. I'll need to make an event_on_close() function, get user input to exit this screen. </p></span>

        <span><p>[23:19] I've created a new branch specifically for the user interface, it's called ui and I'll be working out of here for the time being. I'm coming to terms with the more I learn about SDL, the more mistakes I'm 
            going to make in the long run, so I'm prepared to have to completely rewrite this from the ground up in the future. That means this journal will become extremely important as I document my decisions, therefore I'll
            start adding keywords as bookmarks for control-f through the browser.</p></span>
            
        <span><p> Reminder to build a wiki page for SDL. Useful snippets will need to be a section for API categories. Funny how SDL's documentation is so bare, I mean I get it. I just find it hilarious how certain pages are just blank with no explanation. You'd expect a beast like this to be filled with information. I respect that at the same time. Another interesting thing about SDL, is that nearly every single tutorial on the web assumes that you're using C++, even the ones on the website, despite SDL being built in C. I get that for gamedev that's cool most people will use it for that, but in general as someone new to the language I'm finding that doing research is hindering me a bit -- that being said, I can infer what I have to do from C++ code, it won't be perfect but I'll get where I'm going eventually. </p></span>
        <h3>CONTINUE apsis | ui [2021/06/28/ 0010]</h3>

        <span><p> So I was originally going to use a switch statement to help exit the program safely in the main file by passing an argument, but the thing about this is that command line arguments are set in stone once the program runs. So this switch statement is practiclaly useless for anything other than initalizing the program. I could make my own signal handler to kill the program, but SDL has its down built for this specifcally. Might as well take advantage of the SDL libraries event handlers over the linux standard library. Just a heads up: You still do SDL_DestroyWindow, SDL_DestroyRenderer, SDL_Quit even after SDL_Quit breaks out of the event loop. Also I should be using valgrind more often to catch memory leaks before the program gets too big because once that happens, plugging them will become much more difficult.</p></span>
        
        <span><p> [1226] re: bare documentation... so the SDL github actually contains way more information in the header files that go over things much more in depth.</p></span>
        <span><p> [0139] Things are taking shape now and making much more sense, created a drawing routine for a circle, and set a renderer to render a texture that the circle will be drawn on. I see what Devine
                meant when he said that it was a lot like using an HTML Canvas, but faster.</p></span>
        <span><p> Valgrind is reporting everything is okay as well, no memory leaks that I have to deal with yet.</p></span>
        
        <h3>CONTINUE apsis | ui [2021/06/28 1121] </h3>
        <span><p> I had recently told a story about the time I attempted to use Vulkan over Unity and completely understimated what it would take to create a game engine with low level code. 1200 lines of code to draw a triangle was pretty mind blowing and it made me decide to switch us back to Unity where I could hammer out C# and not have to worry about things that were way over my head at the time. Hilariously, I find myself in a situation where I'm going to be doing just that, at a point my life where I'm much more comfortible with the idea of having to draw things pixel by pixel. Drawing circles is another beast in code, I've seen several complex exampes on how people go about doing this, a very good example, and one that I had chosen to use is the <a href="">Bresenham algorithm</a>, a mid-point circle drawing algorithm that determines the points needed for rasterizing a circle by assigning the first octant at the mid point at 45 degrees, and for every pixel on x and y center, it calculates pixel by pixel each octant up to 8 total octants for a whole 360 degrees. </p></span>
        
        <h3> CONTINUE apsis | ui [2021/06/29 1252]</h3>
        <span><p> [1252] Reorganizing the code. Gonna make this more readable. I'll also be working on the <a href="simple-direct-media-layer.html">SDL wiki entry</a>.</p></span>
        <span><p> [0145] Next we'll need a line / arrow, this will be a rotating phasor. The metronome ticking at f beats per minute, the phasor will rotate 2Ï€ radians once every 60/f seconds. So pretty much for a given tempo in beats per minute, the phasor will make x rotations. </p></span>
        <span><p> [0224] Surface is completely unncessary now, it's an abstraction left over from SDL1.2 so I've removed it from my code in favor of SDL_Texture which is the new way to buffer pixels directly into vram. </p></span>
        <span><p> [0934] The phasor now gets the origin x, origin y, point x, point y arguments. We set double for radians, get the degree by multiplying the radians by pi / 180. Then we get two delta, delta x, delta y. <i>Delta x is the result of cos(angle) * (pX - oX) - (sin(angle) * (pY - oY) + oX;</i> and <i>delta Y is the result of (sin(angle) * (pX - oX) + (cos(angle) * (pY - oY) + oY, </i> afterwards we translate it back: pX += dX and pY += dY. The arguments are then filled by a while loop in the test render that increments the pX and pY values. Which so far so good. 
            <center><img height="200px" src="../gallery/1_apsis_lines.png" alt="An image of a circle with various lines rotating around it's center origin."></center>
    <span><p> That being said, the lines don't clean up, so that's why it looks some weird raytracing technique. I'll have to work that into the while loop. I'll probably be implementing SDL_GetTicks for updating the screen to show it kind of moving in a deltaTime esq manner. Or maybe Devine has a better idea at how that might work. Either way, small steps = accomplishments.
        This code will have to be entirely rewritten once this prototype is done. </p></span>

    <h3> CONTINUE apsis | ui [2021/06/29 1208] </h3>
    <span><p> Cool just woke up, so I need to figure a few things out. Last night I stopped at a point where I felt like I would need to somehow get the window to update every step I take. I looked to SDL_GetTicks for the answer and so far that has not disappointed me, at least in terms of research it looks like many others use that to refresh the screen. I'll also need to make sure the ticks are in a loop while the program is running, right now the main loop running is one that ensures the window stays open. I'll need to end up bundling all of this I guess we'll see. For now, I'm going to do some more reading in that regard. </p></span>

    <span><p>[1259] Protyping: SO we have a while loop x is less than 400, run the loop, incremenet, draw all this stuff at given pos, should work in theory, but uh, we'll see. The increment updates the arguments in the rotPhasor function and passes them through the rotation algorithm and sends them to a final draw line function. I might actually separate the rotator algorithm to its own separate function in the future, but for now this seems to work fine.</p></span>
    <span><p> [0229] So my program actually maanged to break out of an event loop, crashing my terminal and everything running in it, in the process so, you know, my IDE, vim. I lost about five paragraphs of text because who saves their shit anymore. Anyway, turns out SDL_Tick isn't required for what I'm doing I can refresh the render myself by clearing it and forcing it through a loop. The problem I faced was that the eventpoll loop didn't get called cause I had initated another loop if the program was not in a quitting state, which is technically ALL the time. So, instead, the while loop I used for rendering was called everytime it ended, eventually it just broke free and kept incremeneting until I had to send a kill signal to the console itself. Bleh.</p></span>
   
    <span><p>[0525] So tonight was filled with a lot of trial and error, even then I needed some help. I couldn't figure out why the line was static, so I asked around on <a href="merveilles.html">Merveilles</a> before eventually just going directly to <a href="https://ftrv.se/">Sigrid</a> who was more than happy to help. She told me that I didn't actually shift the angle at all. I was so focused on the end points and where they would end up I completely forgot about angle itself. Anyway, the damn thing does its job now. Now I can move on to adding statistics and texts to the metronome.</p></span>
   <center><img class="animated-gif" src="../gallery/2_apsis_spin.mp4.gif" alt="An image of a circle with various lines rotating around it's center origin."></center>
   <span><p>I'll upload a higher res one someday, maybe. Probably not ANYWHO.</p></span>
</div>
