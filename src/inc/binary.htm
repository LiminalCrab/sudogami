<main>	
	<div class="wiki-content">	
		<span><p>Binary is a numeral system which uses only two symbols: "0" and "1". Due to using only two symbols, it is known as a base 2 system. Each digit in binary is referred to as a bit, or a binary digit.</p></span>
        
        <h3>Binary Digits</h3>
        <span><p>Also known as bits, it represents the state of two possible values: 1 or 0, true or false, yes or no, +/-, or on/off. A continous group of binary digits is commonly referred to as a bit string, a bit vector, or a single-dimensional bit array. A group of 8 of these is called one byte.
        
        <h3>Nibble </h3>
        <span><p>Half of a byte, or four bits. In networking, the symbol is typically called a semi-octet, quadbit, or quartet. The nibble has 16 possible values, a nibble can be represented by a single hexadecimal digit and called a hex digit.
            A full byte (Octet, often used in Networking as well.)  is represented by two hexadecimal digits; therefore it is common to display a byte of information as two nibbles. Sometimes, the set of all 256 byte values represented in a 16x16 table gives easily readable hexadecimal codes for each value.
        </p></span>
        <h3>Bytes</h3>
        <span><p> Consists of eight bits. The size of a byte has historically been hardware-depending and no definitive standard existed that mandated the size, sizes from 1 to 48 bits have been used. To disambiguate arbitrarily sized bytes from the common 9-bit definition RFC891 refers to an 8-bit as an octet. Those bits in an octet are usually counted numbering from 0 to 7, or 7 to 0 depending on the bit endianness.</p></span>
        <span><p> Since bytes are to the power of two, binary encoded values range from 0 through 255 for one bytes. The C standard requires that the integral data type unsigned char must hold at least 256 different values, and is represented by at least eight bits. Various implementations of C and C++ reserve 8, 9, 16, 32, or 36 bits for the storage of a byte. In addition, the C and C++ standards require that there are no gaps between two bytes. This means every bit in memory is part of a byte.</p></span>

        <h2>Counting in Binary</h2>
        <span><p> Counting in binary begins from the right most digit which is considered the 'least significant' digit. Since we're only dealing with 0 and 1, we only have two numbers to deal with before we have to increment.
            In the decimal system, we increment after 9, by bringing down the first number (the 0), and incrementing by 1 to create 10. We do this in Binary as well.
        </p></span>


        <table border='1'>
            <tbody>
                <tr>
                    <td>0</td>
                </tr>
                <tr>
                    <td>1</td>
                </tr>
            </tbody>
        </table>

        <span><p>Once we reach 1 in binary, we bring down the 0 column, and increment the next number by 1. It's much easier to think of infinite implicit zeros to the left of every number.</p></span>
        <table border='1'>
            <tbody>
                <tr>
                    <td>1</td>
                </tr>
            </tbody>
        </table>

       <span><p>Becomes</p></span>

        <table border='1'>
            <tbody>
                <tr>
                    <td>10</td>
                </tr>
            </tbody>
        </table>

        <span><p> If you are able to increment, everything after the incremented digit from the earlier binary number carries down.
        </p></span>
        <table border='1'>
            <tbody>
                <tr>
                    <td>Before</td>
                    <td>After</td>
                </tr>
                <tr>
                    <td>10</td>
                    <td>11</td>
                </tr>
            </tbody>
        </table>
        <span><p> Now, we can no longer increment either number, they've reached their maximum. Now we start over, just like in decimal, we reset everything to 0, and flip and implicit 0 to 1.</p></span>
        <table border='1'>
            <tbody>
                <tr>
                    <td>Before</td>
                    <td>After</td>
                </tr>
                <tr>
                    <td>11</td>
                    <td>100</td>
                </tr>
            </tbody>
        </table>
        <span><p>And then start over with the least significant digit. In this case, it is a 0, and can be incremented. As said, once we increment we bring down everything from the last binary digit with it. Prior we had 100, we incremented the right most digit to 1 and brought down the 10 creating 101.</p></span>
        <table border='1'>
            <tbody>
                <tr>
                    <td>Before</td>
                    <td>After</td>
                </tr>
                <tr>
                    <td>100</td>
                    <td>101</td>
                </tr>
            </tbody>
        </table>

        <h3>Binary to Decimal conversion chart</h3>
        
        <table border='1'>
        <tbody>
            <tr>
            <td>Decimal</th>
            <td>Binary</th>
                <tr>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>10</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>11</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>100</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>101</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td>110</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td>111</td>
                </tr>
                <tr>
                    <td>8</td>
                    <td>1000</td>
                </tr>
                <tr>
                    <td>9</td>
                    <td>1001</td>
                </tr>
                <tr>
                    <td>10</td>
                    <td>1010</td>
                </tr>
                <tr>
                    <td>11</td>
                    <td>1011</td>
                </tr>
                <tr>
                    <td> 12</td>
                    <td> 1100</td>
                </tr>
                <tr>
                    <td>13</td>
                    <td>1101</td>
                </tr>
                <tr>
                    <td>14</td>
                    <td>1110</td>
                </tr>
                <tr>
                    <td>15</td>
                    <td>1111</td>
                </tr>
            </tr>
            </tbody>
            </table>
            <span><p> And so on. </p><span>
	</div>
	</div>
